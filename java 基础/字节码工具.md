## ava无可匹敌的变身装备，钢铁侠客的绝密味道

> 原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。

我讨厌写一些业务代码，不仅仅因为它们的原始意图不是我设计的，成功了是产品的功劳，失败了代码要背锅。一个重要的原因，就是重复的代码太多，一个复杂的业务逻辑要找到它的Bug，也要下一番“苦力”。这里说的真的是苦力，而不是脑力，说明了大部分是低劣的重复劳动。哦哦哦，我竟然违背了精英主义论调。

所以随着在项目中有了话语权，我会特别善待这些可怜的同学们。一个问题，直到发现的时候，才发现它的低级，但中间的曲折，很少有人能看到，一个非技术出身的管理者对此就很难理解。职位越是高，就越关注整体的目标达成，对个体的感受却关注的很少，这不是一个好的现象。千里之堤，溃于蚁穴。普通研发的整体水平代表了公司的竞争力。

扯远了。下面介绍几个开发中常用的工具包，可以在Java源文件、语法树、字节码之间进行转换。用好了它们，不仅仅能实现一些黑科技，还能大大提高我们的生产力。

### 1、JavaPoet

有时候，我们要做一些代码生成工具，需要生成一些Java类源文件。如果使用字符串去拼接的话，很容易拼的乱七八糟。为了解放双手，就可以使用工具JavaPoet进行方法或者代码块的构建。它还提供了占位符等一系列方便的操作，使得你生成的代码优美可读，清脆爽口。

特别在写一些框架的时候，可以将一些非常脏、非常累的活儿交给它。



![img](assets/17031ea5d084ef1d)



代码示例。

```
MethodSpec main = MethodSpec.methodBuilder("main")
                .addStatement("int total = 0")
                .beginControlFlow("for(int i=0;i<10;i++)")
                .addStatement("total +=i;")
                .endControlFlow()
                .build();
复制代码
```

### 2、JavaCC

JavaCC是一个语法生成器和语法分析器，可以通过读取一个`.jj`（它是鸡鸡我是姐姐）描述文件来生成一个Java文件。听起来和JavaPoet一样，但它是语法层面的，过程是翻译而不是“构造”，和我们学习的编译原理是一个层面的东西。而且JavaCC生成的文件一般是不可读的，谁让它和yacc以及lex比较像呢。



![img](assets/17031ea8095fedb8)



如果你想要自定义一些表达式，或者做一个特殊格式的解析器，你可能会用到它。

与此类似的还有ANTLR。应用方面，Velocity和FreeMarker都使用JavaCC作为语法解释器；Hibernate则使用ANTLR作为HQL的语法解释器。

不过我还是更喜欢Ragel（不是Java的）多一些。对于这些场景来说，文件生成以后就不再依赖这些工具了，还是高效和好用更重要。

### 3、Javaparser

上面是通过语法树生成Java文件（或者其他文件），Javaparser是通过Java文件生成语法树（AST），然后基于这棵语法树进行Java代码的分析和修改。注意，它可以直接再根据语法树，反向生成Java文件哦。

根据这棵语法树，你可以直接分析一个独立的Java文件，即使这个Java文件乱七八糟，不能通过编译，不用在运行时使用反射等功能。配合JavaPoet可以去做一些非常有意思的功能。比如，Javaparser提取Java文件的注释或者注解，然后通过JavaPoet生成一些自动文档（Swagger），或者进行测试用例的自动填充。

除了这些，Javaparser可以规定十分严格的语法格式，所以使用它做一个代码审查工具，甚至是做一些代码依赖分析，也是可以的。

### 4、Lombok

其实这只是个辅助开发工具，应该有很多研发用起来了，它可以显著的减少代码量。让我们摆脱恼人的get、set、hashCode、equals，甚至log等。

Lombok其实部分上和上面说到的Javaparser类似，不过它是JDK层面的。

在javac将Java文件解析成抽象语法树之后（AST），Lombok则根据自己的注解处理器，动态的修改AST，增加新的节点代码。然后，生成我们最终的字节码。

这个技术，是由javac的注解API来实现的（JSR-269），可以让javac在编译期去干一些事情。



![img](assets/17031eaaf268553f)



JDK做的工作，远比我们表面上用到的那些多的多。

### 5、ByteBuddy

上面几个工具都是把一些其他方式的代码转化为Java源文件，这些Java源文件还需要经过编译这道工序，才能够被真正使用。



![img](assets/17031ead071bb03e)



ByteBuddy可以更进一步，直接动态生成Java类。对，就是直接加载在元空间的那种，在程序运行期间就可以动态的对class进行更改。不需要曲径通幽，直达目的。

它的底层是ASM，所以ByteBuddy是可以直接修改字节码的，是一种**字节码增强工具**。

于此类似的工具还有JAVASIST、CGLiB等。

如果你在做一些代理类的工作，或者做一些APM等，想要实现类似Aspectj之类的功能，再或者类似Arthas那样的故障排查工具，那这些工具正适合。