# CA 证书

在学习CA 证书之前请先了解非对称加密、对称加密、数字签名、消息摘要、消息认证码等等

## 证书的应用场景

> 下面我们来通过证书的代表性应用场景来理解证书的作用。 
>
> 下图展示了Alice向Bob发送密文的场景，在生成密文时所使用的Bob的公钥是通过认证机构获取的。 
>
> 认证机构必须是可信的，对于“可信的第三方”，下图中会使用Trent这个名字，这个词是从trust（信任）一词演 变而来的。

![image-20210413145446330](assets/image-20210413145446330.png)

下面让我们对照着上图来看一看这些步骤具体都做了些什么。 

我们可以将 Bob 理解为百度，将Alice 理解为 浏览器

1、Bob生成密钥对 

- 可以将bob看成百度, 提供是web服务器 

- 生成一个密钥对 

  - 公钥 -> 分发 （发送给需要加密数据信息的一方，比如浏览器、C/S中的 client端等等）

  - 私钥 -> 百度留着 

2、Bob在认证机构Trent注册自己的公钥 

3、 百度找到权威的中间机构来为自己颁发证书

- 百度找了一大家都信赖的机构, 来证明这个公钥是百度的 
- 认证机构会生成一个证书, 写明了公钥属于百度 
  - 认证机构也有一个非对称加密的密钥对
  - 认证机构使用自己的私钥对百度的公钥进行签名, 生成了证书
  - 认证机构将证书发送给百度 

 4、认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书 

5、Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书） 

- alice可以看做一个客户 -> 浏览器
- 客户端访问的百度 -> 得到了百度的证书
  - 证书中有百度的公钥 
- 客户端需要使用认证机构的公钥对证书进行验证 
  - 客户端怎么会有认证机构的公钥
    - window会预装, 或者用户自己安装（比如银行的证书、12306证书等等）

6、Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性

- 使用认证机构的公钥验证百度证书中签名的数据
  - 验证百度的公钥 是否有效
  - 验证证书中的域名是否是百度的域名 
  - 验证百度证书的有效期

7、Alice用Bob的公钥加密消息并发送给Bob 

- 非对称加密
- 使用公钥加密 -> 对称加密秘钥分发

8、Bob用自己的私钥解密密文得到Alice的消息 

- 服务器使用私钥解密 -> 得到对称加密的秘钥 





## 证书标准规范 X.509

> 证书是由认证机构颁发的，使用者需要对证书进行验证，因此如果证书的格式千奇百怪那就不方便了。于是， 人们制定了证书的标准规范，其中使用最广泛的是由ITU（International TelecommumcationUnion，国际电信联 盟）和ISO（IntemationalOrganizationforStandardization, 国际标准化组织）制定的X.509规范。很多应用程序都支 持x.509并将其作为证书生成和交换的标准规范。 
>
> X.509是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准，因此(理论上)为一种应用创建的证书 可以用于任何其他符合X.509标准的应用。X.509证书的结构是用ASN1(Abstract Syntax Notation One)进行描述数据 结构，并使用ASN.1语法进行编码
>
> 在一份证书中，必须证明公钥及其所有者的姓名是一致的。对X.509证书来说，认证者总是**CA**或由CA指定的 人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义 了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式) 
>
> 一般来说，一个数字证书内容可能包括基本数据（版本、序列号) 、所签名对象信息（ 签名算法类型、签发者信 息、有效期、被签发人、签发的公开密钥）、CA的数字签名，等等。



### 证书规范

前使用最广泛的标准为ITU和ISO联合制定的X.509的 v3版本规范 (RFC5280）, 其中定义了如下证书信息域： 

- **版本号(Version Number）**：规范的版本号，目前为版本3，值为0x2； 
- **序列号（Serial Number）**：由CA维护的为它所发的每个证书分配的一的列号，用来追踪和撤销证书。只要 拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节； 
- **签名算法（Signature Algorithm）**：数字签名所采用的算法，如： 
  - sha256-with-RSA-Encryption 
  - ccdsa-with-SHA2S6； 
- **颁发者（Issuer）**：发证书单位的标识信息，如 ” C=CN，ST=Beijing, L=Beijing, O=org.example.com， CN=ca.org。example.com ”； 
- **有效期(Validity)**: 证书的有效期很，包括起止时间。 
- **主体(Subject) **: 证书拥有者的标识信息（Distinguished Name），如：" C=CN，ST=Beijing, L=Beijing, CN=person.org.example.com”； 
- **主体的公钥信息(SubJect Public Key Info）**：所保护的公钥相关的信息： 
- 公钥算法 (Public Key Algorithm）公钥采用的算法； 
  - 主体公钥（Subject Unique Identifier）：公钥的内容。 
- **颁发者唯一号（Issuer Unique Identifier）**：代表颁发者的唯一信息，仅2、3版本支持，可选； 
- **主体唯一号（Subject Unique Identifier）**：代表拥有证书实体的唯一信息，仅2，3版本支持，可选： 
- **扩展（Extensions，可选）**: 可选的一些扩展。中可能包括： 
  - **Subject Key Identifier**：实体的秘钥标识符，区分实体的多对秘钥； 
  - **Basic Constraints**：一指明是否属于CA; 
  - **Authority Key Identifier**：证书颁发者的公钥标识符； 
  - **CRL Distribution Points**: 撤销文件的颁发地址； 
  - **Key Usage**：证书的用途或功能信息。

此外，证书的颁发者还需要对证书内容利用自己的私钥添加签名， 以防止别人对证书的内容进行篡改。 

  

### 证书格式

X.509规范中一般推荐使用PEM(Privacy Enhanced Mail）格式来存储证书相关的文件。证书文件的文件名后缀一般 为 .crt 或 .cer 。对应私钥文件的文件名后缀一般为 .key。证书请求文件的文件名后綴为 .csr 。有时候也统一用 pem作为文件名后缀。 PEM格式采用文本方式进行存储。一般包括首尾标记和内容块，内容块采用Base64进行编码。

**编码格式总结**：

- **X.509 DER(Distinguished Encoding Rules)**编码，后缀为：**.der .cer .crt**
- **X.509 BASE64**编码 (PEM格式)，后缀为：**.pem .cer .crt** 

例如，一个PEM格式（base64编码）的示例证书文件内容如下所示：

```
-----BEGIN CERTIFICATE-----
MIIDyjCCArKgAwIBAgIQdZfkKrISoINLporOrZLXPTANBgkqhkiG9w0BAQsFADBn MSswKQYDVQQLDCJDcmVhdGVkIGJ5IGh0dHA6Ly93d3cuZmlkZGxlcjIuY29tMRUw EwYDVQQKDAxET19OT1RfVFJVU1QxITAfBgNVBAMMGERPX05PVF9UUlVTVF9GaWRk bGVyUm9vdDAeFw0xNzA0MTExNjQ4MzhaFw0yMzA0MTExNjQ4MzhaMFoxKzApBgNV BAsMIkNyZWF0ZWQgYnkgaHR0cDovL3d3dy5maWRkbGVyMi5jb20xFTATBgNVBAoM DERPX05PVF9UUlVTVDEUMBIGA1UEAwwLKi5iYWlkdS5jb20wggEiMA0GCSqGSIb3 DQEBAQUAA4IBDwAwggEKAoIBAQDX0AM198jxwRoKgwWsd9oj5vI0and9v9SB9Chl gZEu6G9ZA0C7BucsBzJ2bl0Mf6qq0Iee1DfeydfEKyTmBKTafgb2DoQE3OHZjy0B QTJrsOdf5s636W5gJp4f7CUYYA/3e1nxr/+AuG44Idlsi17TWodVKjsQhjzH+bK6 8ukQZyel1SgBeQOivzxXe0rhXzrocoeKZFmUxLkUpm+/mX1syDTdaCmQ6LT4KYYi soKe4f+r2tLbUzPKxtk2F1v3ZLOjiRdzCOA27e5n88zdAFrCmMB4teG/azCSAH3g Yb6vaAGaOnKyDLGunW51sSesWBpHceJnMfrhwxCjiv707JZtAgMBAAGjfzB9MA4G A1UdDwEB/wQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAWBgNVHREEDzANggsq LmJhaWR1LmNvbTAfBgNVHSMEGDAWgBQ9UIffUQSuwWGOm+o74JffZJNadjAdBgNV HQ4EFgQUQh8IksZqcMVmKrIibTHLbAgLRGgwDQYJKoZIhvcNAQELBQADggEBAC5Y JndwXpm0W+9SUlQhAUSE9LZh+DzcSmlCWtBk+SKBwmAegbfNSf6CgCh0VY6iIhbn GlszqgAOAqVMxAEDlR/YJTOlAUXFw8KICsWdvE01xtHqhk1tCK154Otci60Wu+tz 1t8999GPbJskecbRDGRDSA/gQGZJuL0rnmIuz3macSVn6tH7NwdoNeN68Uj3Qyt5 orYv1IFm8t55224ga8ac1y90hK4R5HcvN71aIjMKrikgynK0E+g45QypHRIe/z0S /1W/6rqTgfN6OWc0c15hPeJbTtkntB5Fqd0sfsnKkW6jPsKQ+z/+vZ5XqzdlFupQ 29F14ei8ZHl9aLIHP5s=
-----END CERTIFICATE-----
```

证书中的解析出来的内容：

```
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            c0:23:ac:a7:b2:24:1c:09
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, CN=ca, O=k8s
        Validity
            Not Before: Apr 13 03:43:58 2021 GMT
            Not After : Apr 13 03:43:58 2022 GMT
        Subject: C=CN, CN=ca, O=k8s
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:d5:5b:ea:fa:00:84:f3:76:4d:16:79:61:2f:e8:
                    92:e8:3c:26:5f:c6:8e:b1:5c:6f:c1:ac:01:ed:39:
                    32:ed:76:27:b1:77:10:f0:0c:88:07:f8:77:b4:05:
                    eb:eb:a1:41:3a:eb:fd:ef:2b:20:45:87:30:58:69:
                    7d:c5:c5:39:f4:bb:ee:31:4d:80:3f:cd:2e:83:b3:
                    80:86:35:00:82:65:c6:d0:36:5e:70:71:ae:3f:93:
                    91:13:83:34:77:15:d7:f0:aa:b5:c9:07:32:96:ff:
                    85:75:7c:73:70:0b:db:34:ac:d1:41:31:5e:7c:70:
                    a6:0a:62:4f:c8:35:ee:26:e0:41:35:06:22:98:2d:
                    56:20:b5:d8:bc:e0:3b:2d:41:01:aa:9e:2d:91:1e:
                    0b:18:ce:09:a7:53:87:8b:07:05:33:1c:57:1e:c2:
                    6d:f2:80:31:47:44:dc:ee:5f:a5:af:e0:bf:22:1f:
                    52:35:2c:f4:92:58:84:7b:0c:01:6e:80:f1:4c:dc:
                    10:27:1d:0d:80:a3:ad:5f:bd:c9:79:6d:4b:2b:76:
                    96:16:8f:94:ee:ec:95:17:7a:0d:11:48:94:c3:d5:
                    01:95:04:99:22:ab:8e:95:af:d6:0f:e9:81:73:c0:
                    29:59:fa:c9:36:39:38:c0:ef:1e:eb:09:54:2d:ce:
                    7d:a3
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                E4:35:09:FC:E0:C1:5C:00:68:8C:EE:C9:13:13:83:3B:77:69:A9:F3
            X509v3 Authority Key Identifier: 
                keyid:E4:35:09:FC:E0:C1:5C:00:68:8C:EE:C9:13:13:83:3B:77:69:A9:F3

            X509v3 Basic Constraints: 
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         08:d6:58:cc:eb:9a:b7:7d:3f:c5:13:db:9e:40:63:72:d6:50:
         fa:14:17:46:1b:33:0a:e9:f2:ba:71:2e:ac:89:10:34:d3:c6:
         bf:98:90:c6:12:63:e6:82:68:b4:64:b6:89:1f:1f:aa:91:5b:
         fc:97:38:43:c4:84:27:0d:ce:1f:73:2b:b2:f2:7c:f9:8e:97:
         4a:6b:08:a2:30:3f:d8:9b:6c:1e:19:94:9b:5a:33:23:04:93:
         7b:6f:c7:78:ce:9c:68:ff:9d:c1:c3:ea:64:7f:29:b1:3a:d7:
         17:fc:2f:f1:53:92:3d:23:75:a3:63:6d:f0:d3:0b:64:1d:ee:
         34:a1:b1:8a:c0:f8:e0:c8:ab:c0:ff:99:d2:ec:ed:3b:71:93:
         08:28:59:ab:eb:63:74:19:41:6c:fc:b6:f0:5a:9a:aa:9c:84:
         0d:6a:af:1d:db:43:3f:56:5c:61:85:70:e8:ea:de:9b:52:d3:
         fc:0e:43:10:98:81:8d:dd:85:38:a4:35:b4:5b:b7:4d:c9:37:
         61:b2:60:30:79:38:83:f6:f9:37:88:97:c2:66:dc:81:b0:b4:
         e0:87:39:1c:f9:7e:e5:87:1f:da:74:ab:ba:48:dd:83:5d:a3:
         04:8a:0a:53:58:ef:c3:ec:02:7b:0c:a2:ca:64:a7:19:ca:2d:
         51:9a:ec:ca
```



**X.509**是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准，因此(理论上)为一种应用创建的证 书可以用于任何其他符合X.509标准的应用。X.509证书的结构是用ASN1(Abstract Syntax Notation One)进行描述数 据结构，并使用ASN.1语法进行编码。 

X.509规范中一般推荐使用PEM(Privacy Enhanced Mail）格式来存储证书相关的文件。

- 证书文件的文件名后缀一般为 .crt 或 .cer 
- 对应私钥文件的文件名后缀一般为 .key 
- 证书请求文件的文件名后綴为 .csr 
- 有时候也统一用pem作为文件名后缀。



### CA证书

证书是用来证明某某东西确实是某某东西的东西（是不是像绕口令？）。通俗地说，证书就好比上文里面的公 章。通过公章，可以证明对应的证件的真实性。 理论上，人人都可以找个证书工具，自己做一个证书。那如何防止坏人自己制作证书出来骗人捏？请看后续 CA 的介绍。

> CA是Certificate Authority的缩写，也叫“证书授权中心”。 它是负责管理和签发证书的第三方机构, 好比一个可信任的中介公司。一般来说，CA必须是所有行业和所有公众 都信任的、认可的。因此它必须具有足够的权威性。就好比A、B两公司都必须信任C公司，才会找 C 公司作为公章的中介。 



#### CA 证书

CA 证书，顾名思义，就是CA颁发的证书。 前面已经说了，人人都可以找工具制作证书。但是你一个小破孩制作出来的证书是没啥用处的。因为你不 是权威的CA机关，你自己搞的证书不具有权威性。 

比如，某个坏人自己刻了一个公章，盖到介绍信上。但是别人一看，不是受信任的中介公司的公章，就不 予理睬。坏蛋的阴谋就不能得逞啦。



#### 证书信任链

证书直接是可以有信任关系的, 通过一个证书可以证明另一个证书也是真实可信的. 实际上，证书之间的信 任关系，是可以嵌套的。比如，C 信任 A1，A1 信任 A2，A2 信任 A3......这个叫做证书的信任链。只要你信 任链上的头一个证书，那后续的证书，都是可以信任滴。 

假设 C 证书信任 A 和 B；然后 A 信任 A1 和 A2；B 信任 B1 和 B2。则它们之间，构成如下的一个树形关系 （一个倒立的树）。

![image-20210413151259670](assets/image-20210413151259670.png)

 处于最顶上的树根位置的那个证书，就是“**根证书**”。除了根证书，其它证书都要依靠上一级的证书，来证 明自己。那谁来证明“根证书”可靠捏？实际上，根证书自己证明自己是可靠滴（或者换句话说，根证书是 不需要被证明的）。 

聪明的同学此刻应该意识到了：根证书是整个证书体系安全的根本。所以，如果某个证书体系中，根证书 出了问题（不再可信了），那么所有被根证书所信任的其它证书，也就不再可信了。



### 证书有啥用

1、验证网站是否可信，针对Https

通常，我们如果访问某些敏感的网页（比如用户登录的页面），其协议都会使用 HTTPS 而不是 HTTP。因为 HTTP 协议是明文的，一旦有坏人在偷窥你的网络通讯，他/她就可以看到网络通讯的内 容（比如你的密码、银行帐号、等）；而 HTTPS 是加密的协议，可以保证你的传输过程中，坏蛋无 法偷窥。 

但是，千万不要以为，HTTPS 协议有了加密，就可高枕无忧了。俺再举一个例子来说明，光有加密 是不够滴。假设有一个坏人，搞了一个假的网银的站点，然后诱骗你上这个站点。假设你又比较单 纯，一不留神，就把你的帐号，口令都输入进去了。那这个坏蛋的阴谋就得逞鸟。 

为了防止坏人这么干，HTTPS 协议除了有加密的机制，还有一套证书的机制。通过证书来确保，某 个站点确实就是某个站点。 有了证书之后，当你的浏览器在访问某个 HTTPS 网站时，会验证该站点上的 CA 证书（类似于验证 介绍信的公章）。如果浏览器发现该证书没有问题（证书被某个根证书信任、证书上绑定的域名和 

该网站的域名一致、证书没有过期），那么页面就直接打开；否则的话，浏览器会给出一个警告， 告诉你该网站的证书存在某某问题，是否继续访问该站点？下面给出 IE 和 Firefox 的抓图：

![image-20210413151648639](assets/image-20210413151648639.png)

 ![image-20210413151702529](assets/image-20210413151702529.png)

大多数知名的网站，如果用了 HTTPS 协议，其证书都是可信的（也就不会出现上述警告）。所以， 今后你如果上某个知名网站，发现浏览器跳出上述警告，你就要小心啦！   



2、验证某文件是否可信

证书除了可以用来验证某个网站，还可以用来验证某个文件是否被篡改。具体是通过证书来制作文 件的数字签名。制作数字签名的过程太专业，咱就不说了。后面专门告诉大家如何验证文件的数字 签名。考虑到大多数人用 Windows 系统，俺就拿 Windows 的例子来说事儿。

比如，俺手头有一个 Google Chrome的安装文件（带有数字签名）。当俺查看该文件的属性，会看 到如下的界面。眼神好的同学，会注意到到上面有个“**数字签名**”的标签页。如果没有出现这个标签 页，就说明该文件没有附带数字签名。

![image-20210413152012944](assets/image-20210413152012944.png)

一般来说，签名列表中，有且仅有一个签名。选中它，点“**详细信息**”按钮。跳出如下界面： 通常这个界面会显示一行字：“**该数字签名正常**”（图中红圈标出）。如果有这行字，就说明该文件 从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。如果该文件被篡改过了（比如，感 染了病毒、被注入木马），那么对话框会出现一个警告提示“**该数字签名无效**”

![image-20210413151956712](assets/image-20210413151956712.png)

不论签名是否正常，你都可以点“查看证书”按钮。这时候，会跳出证书的对话框。如下：

![image-20210413151944841](assets/image-20210413151944841.png)

![image-20210413152031169](assets/image-20210413152031169.png)

从后一个界面，可以看到刚才说的证书信任链。图中的信任链有3层： 

- 第1层是根证书（verisign）。 
- 第2层是 symantec 专门用来签名的证书。 
- 第3层是 Google自己的证书。 

目前大多数知名的公司（或组织机构），其发布的可执行文件（比如软件安装包、驱动程序、安全 补丁），都带有数字签名。你可以自己去看一下。 

建议大伙儿在安装软件之前，都先看看是否有数字签名？如果有，就按照上述步骤验证一把。一旦 数字签名是坏的，那可千万别装





## 公共基础设施（PKI）

> 仅制定证书的规范还不足以支持公钥的实际运用，我们还需要很多其他的规范，例如证书应该由谁来颁发，如 何颁发，私钥泄露时应该如何作废证书，计算机之间的数据交换应采用怎样的格式等。这一节我们将介绍能够 使公钥的运用更加有效的公钥基础设施。

### 什么是公钥基础设施

公钥基础设施（Public-Key infrastructure）是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。公 钥基础设施一般根据其英语缩写而简称为PKI。 

PKI只是一个总称，而并非指某一个单独的规范或规格。例如，RSA公司所制定的PKCS（Public-Key Cryptography Standards，公钥密码标准）系列规范也是PKI的一种，而互联网规格RFC（Requestfor Comments）中也有很多与 PKI相关的文档。此外，X.509这样的规范也是PKI的一种。在开发PKI程序时所使用的由各个公司编写的 API（Application Programming Interface, 应用程序编程接口）和规格设计书也可以算是PKI的相关规格。 



### PKI 的组成要素

PKI的组成要素主要有以下三个： 

- 用户 --- 使用PKI的人 
- 认证机构 --- 颁发证书的人 
- 仓库 --- 保存证书的数据库

![image-20210413152334145](assets/image-20210413152334145.png)



- 用户 

  - 申请证书的人 -> web服务器端 

    - 申请证书 
      - 生成密钥对 , 或者委托ca生成 
      - 将公钥发送给CA 
      - ca使用自己的私钥对得到公钥签名 
      - 将证书发送给用户 
    - 发送证书 
      - 当客户端访问服务器的时候发送证书给客户端 

    - 注销证书 
      - 当发现私钥泄露之后 

  - 使用证书的人 -> 客户端

  - 验证对方的身份信息户端 

    - 接收证书 
    - 验证对方的身份信息 

- CA 认证机构

  - 可以生产密钥对(可选) 
  - 对公钥签名 
  - 吊销证书

- 仓库

  - 存储证书 -> 公钥



#### 用户

> 用户就是像Alice、Bob这样使用PKI的人。用户包括两种：一种是希望使用PKI注册自己的公钥的人，另一种是希 望使用已注册的公钥的人。我们来具体看一下这两种用户所要进行的操作。 

- **注册公钥的用户所进行的操作** 
  - 生成密钥对（也可以由认证机构生成） 
  - 在认证机构注册公钥 
  - 向认证机构申请证书 
  - 根据需要申请作废已注册的公钥 
  - 解密接收到的密文 
  - 对消息进行数字签名 

- **使用已注册公钥的用户所进行的操作** 

  - 将消息加密后发送给接收者 
  - 验证数字签名

  ```
  					==================== 小知识点 ====================
  浏览器如何验证SSL证书
  
  1. 在IE浏览器的菜单中点击“工具 /Internet选项”，选择“内容”标签，点击“证书”按钮，然后就可以看到IE 浏览器已经信任了许多“中级证书颁发机构”和“受信任的根证书颁发机 构。当我们在访问该网站时，浏览器 就会自动下载该网站的SSL证书，并对证书的安全性进行检查。
  
  2. 由于证书是分等级的，网站拥有者可能从根证书颁发机构领到证书，也可能从根证书的下一级（如某个国家 的认证中心，或者是某个省发出的证书）领到证书。假设我们正在访问某个使用 了 SSL技术的网站，IE浏 览器就会收到了一个SSL证书，如果这个证书是由根证书颁发机构签发的，IE浏览器就会按照下面的步骤来 检查：浏览器使用内 置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信 任的颁证机构签发的，这个网站就是安全可靠的；如果该SSL证书不是根服 务器签发的，浏览器就会自动检 查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证 书也是可信的。
  ```



#### 认证机构

认证机构（Certification Authority，CA）是对证书进行管理的人。上面的图中我们给它起了一个名字叫作Trent。 认证机构具体所进行的操作如下： 

- **生成密钥对 (也可以由用户生成)**

  > 生成密钥对有两种方式：一种是由PKI用户自行生成，一种是由认证机构来生成。在认证机构生成用户密钥
  > 对的情况下，认证机构需要将私钥发送给用户，这时就需要使用PKCS#12（Personal Information Exchange Syntax Standard）等规范。

  

- 在注册公钥时对本人身份进行认证, 生成并颁发证书

  > 在用户自行生成密钥对的情况下，用户会请求认证机构来生成证书。申请证书时所使用的规范是由 PKCS#10（Certification Request Syntax Standard）定义的。 
  >
  > 认证机构根据其认证业务准则（Certification Practice Statement，CPS）对用户的身份进行认证，并生成证 书。在生成证书时，需要使用认证机构的私钥来进行数字签名。生成的证书格式是由PKCS#6 （Extended- Certificate Syntax Standard）和 X.509定义的。

- 作废证书 

  > 当用户的私钥丢失、被盗时，认证机构需要对证书进行作废（revoke）。此外，即便私钥安然无恙，有时 候也需要作废证书，例如用户从公司离职导致其失去私钥的使用权限，或者是名称变更导致和证书中记载 的内容不一致等情况。 
  >
  > 纸质证书只要撕毁就可以作废了，但这里的证书是数字信息，即便从仓库中删除也无法作废，因为用户会 保存证书的副本，但认证机构又不能人侵用户的电脑将副本删除。 
  >
  > 要作废证书，认证机构需要制作一张证书 **作废清单（****Certificate Revocation List),****简称为****CRL** 。 CRL是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单，并由认证机构加 上数字签名。证书序列号是认证机构在颁发证书时所赋予的编号，在证书中都会记载。 
  >
  > PKI用户需要从认证机构获取最新的CRL,并查询自己要用于验证签名（或者是用于加密）的公钥证书是否已 经作废这个步骤是非常重要的。 
  >
  > 假设我们手上有Bob的证书，该证书有合法的认证机构签名，而且也在有效期内，但仅凭这些还不能说明 该证书一定是有效的，还需要查询认证机构最新的CRL，并确认该证书是否有效。一般来说，这个检查不 是由用户自身来完成的，而是应该由处理该证书的软件来完成，但有很多软件并没有及时更能CRL。 

认证机构的工作中，公钥注册和本人身份认证这一部分可以由注册机构（Registration Authority，RA) 来分担。 这样一来，认证机构就可以将精力集中到颁发证书上，从而减轻了认证机构的负担。不过，引入注册机构也有 弊端，比如说认证机构需要对注册机构本身进行认证，而且随着组成要素的增加，沟通过程也会变得复杂，容 易遭受攻击的点也会增



#### 仓库

仓库（repository）是一个保存证书的数据库，PKI用户在需要的时候可以从中获取证书．它的作用有点像打电话 时用的电话本。在本章开头的例子中，尽管没特别提到，但Alice获取Bob的证书时，就可以使用仓库。仓库也叫 作证书目录。 







## SSL/TLS

传统的http通信过程与http是的区别如下：

![image-20210413160948957](assets/image-20210413160948957.png)

我们看到 ssl 在 tcp 与应用层之间加了一层，用于加密与解密数据

- **SSL**：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安 全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已 被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。 SSL协议位于TCP/IP协议与各种应用层 协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建 立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手 协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方 进行身份认证、协商加密算法、交换加密密钥等。 

- **TLS**：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。 TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0 协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 **RFC** 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的 传输协议（例如 TCP）上面。 



SSL/TLS协议提供的服务主要有： 

 1、认证用户和服务器，确保数据发送到正确的客户机和服务器； 

2、 加密数据以防止数据中途被窃取； 

3、 维护数据的完整性，确保数据在传输过程中不被改变。

过程如下图：

![image-20210413154415568](assets/image-20210413154415568.png)



![image-20210413162606282](assets/image-20210413162606282.png)





### SSL\TLS 双向认证

ssl、tls 双向认证流程如下，依据与同一个CA 认证机构来签发 client 与 server端的证书

![SSL workflow](assets/b05863e452a0678db087e98ca16b36dd.png) 







### 扩展

#### Q1: CA 介绍
CA: 证书授权中心(certificate authority)

- 它呢，类似于国家出入境管理处一样，给别人颁发护照；
- 也类似于国家工商管理局一样，给公司/企业颁发营业执照。

CA 有两大主要性质：

- CA 本身是受信任的 （国际认可的）

- 给他受信任的申请对象颁发证书

>   和办理护照一样，要确定你的合法身份，你不能是犯罪分子或造反派。当然，你需要被收保护费，同时，CA 机构可以随时吊销你的证书。

#### Q2: CA 证书长啥样
其实你的电脑中有一堆证书。你可以看一看嘛：

- 360 浏览器: 选项/设置-> 高级设置 -> 隐私于安全 -> 管理 HTTPS/SSL 证书 -> 证书颁发机构
- 火狐浏览器: 首选项 -> 高级 -> 证书 -> 查看证书 -> 证书机构
- chrome浏览器: 设置 -> 高级 -> 管理证书 -> 授权中心
- ubuntu: /etc/ssl/certs/xxx_CA.pem (或 xxx_Certification_Authority.pem)

这些都是 CA 的证书！



#### Q3: CA 的证书 ca.crt 和 SSL Server 的证书 server.crt 是什么关系呢

1、SSL Server 自己生成一个私钥/公钥对。server.key/server.pub // 私钥加密，公钥解密！

2、server.pub 生成一个请求文件 server.req. 请求文件中包含有 server 的一些信息，如域名/申请者/公钥等。

3、server 将请求文件 server.req 递交给 CA 机构，CA 机构验明正身后，将用 ca.key 和请求文件加密生成 server.crt

4、由于 ca.key 和 ca.crt 是一对, 于是 ca.crt 可以解密 server.crt.



#### Q4: 举例说明
如果 SSL Client 想要校验 SSL server. 那么 SSL server 必须要将他的证书 server.crt 传给 client. 然后 client 用 ca.crt 去校验 server.crt 的合法性。

如果 server 是一个钓鱼网站，那么 CA 是不会给他颁发合法 server.crt 证书的，这样 client 用 ca.crt 去校验，就会失败。比如浏览器作为一个 SSL Client,你想访问合法的淘宝网站 https://www.taobao.com, 结果不慎访问到 https://wwww.jiataobao.com, 那么浏览器将会检验到这个假淘宝钓鱼网站的非法性，提醒用户不要继续访问！这样就可以保证 client 的所有 https 访问都是经过安全检查的。



#### 何为 SSL/TLS 单向认证，双向认证？

单向认证：指的是只有一个对象校验对端的证书合法性
通常是客户端来校验服务器的合法性。那么 client 需要一个 ca.crt, 服务器需要 server.crt, server.key

> 例如：浏览器校验各个 HTTPS 网站的合法性。如果导航栏有绿色的小锁，说明网站合法；如果是红色小锁，说明该网站证书校验不过。

也可以是服务器来校验客户端的合法性。那么 server 需要一个 ca.crt, 客户端需要 client.crt, client.key

> 例如: 亚马逊物联网平台(AWS IoT) 给每个设备颁发证书，所有设备要想连接上 AWS, 必须使用其提供的客户端证书

双向认证：指的是相互校验，服务器需要校验每个 client 证书, client 也需要校验服务器证书

- server 需要 server.key 、server.crt 、ca.crt
- client 需要 client.key 、client.crt 、ca.crt

不认证：指的是不相互校验证书，但仍然使用 TLS 连接

> 证书校验只是 TLS 连接过程中的一小步



### 证书格式说明

- .crt 表示证书, 
- .key 表示私钥, 
- .req 表示请求文件,
- .csr 也表示请求文件, 
- .pem 表示 pem 格式，
- .der 表示 der 格式。 






### 通信过程

![image-20210413154415568](assets/image-20210413154415568.png)





## Https 单向认证

![image-20210413162716830](assets/image-20210413162716830.png)

https 认证流程图过程解释如下：

1、服务器要准备的 

- 生成密钥对 
- 将公钥发送给ca, 由ca签发证书 
- 将ca签发的证书和非对称加密的私钥部署到当前的web服务器 

2、通信流程 

①、客户端连接服务器, 通过一个域名 

- 域名和IP地址的关系 
  - 域名要绑定IP地址 
    - 一个域名只能绑定一个IP地址
  - IP地址需要被域名绑定 
    - 一个IP地址可以被多个域名绑定 
- 客户端访问的域名会别解析成IP地址, 通过IP地址访问web服务器

②、 服务器收到了客户端的请求 

- 服务器将CA签发的证书发送给浏览器(客户端) 

③、客户端拿到了服务器的公钥证书 

- 读这个公钥 证书 
  - 验证域名 
  - 有效期 
  - ca签发机构 
  - 服务器的公钥 

④、客户会生成一个随机数 (作为对称加密的秘钥来使用的) 

- 使用服务器的公钥就这个随机数进行加密将这个加密之后 秘钥发送给服务器 
- 将这个加密之后 秘钥发送给服务器

⑤、服务器对收到的密文解密 

- 使用服务器的是要解密, 得到对称加密的秘钥 

⑥、数据的传输 

- 使用对称加密的方式对数据进行加密



### 证书详细工作流程

 ![证书工作流](assets/0952f1a7026a53dae87bd4b1d45b26d3.png) 

1）申请认证：服务器需自己生成公钥私钥对pub_svr & pri_svr，同时根据 pub_svr 生成请求文件 csr, 提交给 CA 机构，csr 中含有公钥、组织信息、个人信息(域名)等信息。(图一中 server.req 就是 csr 请求文件)

2）审核信息：CA 机构通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等。

3）签发证书：如信息审核通过，CA 机构会向申请者签发认证文件-证书。
证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。
签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名。（图一中生成 server.crt）

4）返回证书：client 如果请求验证服务器，服务器需返回证书文件。（图一中 handshake 传回 server.crt）

5）client验证证书：client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法。客户端然后验证证书相关的域名信息、有效时间是否吊销等信息。
客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。(图一中check 可选，我们可以选择不验证服务器证书的有效性)

6）秘钥协商：验证通过后，Server 和 Client 将进行秘钥协商。接下来 Serve r和 Client 会采用对称秘钥加密。(对称加密时间性能优)（图一中 pre-master/change_cipher_spec/encrypted_handshake_message 过程）

7）数据传输：SSL Server 和 SSL Client 采用对称秘钥加密解密数据。



### SSL\TLS 单向认证流程

 ![单项认证](assets/e801a77d7b9dd200c9dd6a7f904e3f25.png) 

(1) client_hello

客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下：

- 支持的最高 TLS 协议版本 version，从低到高依次 SSLv2, SSLv3, TLSv1, TLSv1.1, TLSv1.2, 当前基本不再使用低于 TLSv1 的版本

- 客户端支持的加密套件 cipher suites 列表， 每个加密套件对应前面 TLS 原理中的四个功能的组合：

  - 认证算法 Au (身份验证)
  - 密钥交换算法 KeyExchange(密钥协商)
  - 对称加密算法 Enc (信息加密)
  - 信息摘要 Mac(完整性校验)

- 支持的压缩算法 compression methods 列表，用于后续的信息压缩传输
- 随机数 random_C，用于后续的密钥的生成
- 扩展字段 extensions，支持协议与算法的相关参数以及其它辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段作用

(2) server_hello + server_certificate + sever_hello_done
- server_hello, 服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 等，其中随机数用于后续的密钥协商;
- server_certificates, 服务器端配置对应的证书链，用于身份验证与密钥交换;
- server_hello_done，通知客户端 server_hello 信息发送结束;



(3) 证书校验

- [证书链]的可信性 trusted certificate path，方法如前文所述;
- 证书是否吊销 revocation，有两类方式离线 CRL 与在线 OCSP，不同的客户端行为会不同;
- 有效期 expiry date，证书是否在有效时间范围;
- 域名 domain，核查证书域名是否与当前的访问域名匹配，匹配规则后续分析;



(4) client_key_exchange + change_cipher_spec + encrypted_handshake_message

- client_key_exchange，合法性验证通过之后，客户端计算产生随机数字 Pre-master，并用证书公钥加密，发送给服务器;
- 此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，计算得到协商密钥;
- enc_key=Fuc(random_C, random_S, Pre-Master)
- change_cipher_spec，客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信;
- encrypted_handshake_message，结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证



(5) change_cipher_spec + encrypted_handshake_message

- 服务器用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master);
- 计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;
- change_cipher_spec, 验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信;
- encrypted_handshake_message, 服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥 session secret 与算法加密并发送到客户端;

(6) 握手结束
客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成



(7) 加密通信
开始使用协商密钥与算法进行加密通信。



## 专栏

### 身份确认和认证业务准则

认证机构确认"本人"身份的方法和认证机构的认证业务准则（CertificatePractice Statement, CPS，的内容有关。如果认证机构提供的是测试用的服务，那么可能完全不会进行任何身份确 认。如果是政府部门运營的认证机构，可能就需要根据法律规定来进行身份确认。如果是企业 面向内部设立的认证机构，那就可能会给部门负责人打电话直接确认。 

例如，VeriSign的认证业务准则中将身份确认分为Class1 ~ 3共三个等级 

- Class1：通过向邮箱发送件来确认本人身份 
- Class2：通过第三方数据库来确认本人身份 
- Class3：通过当面认证和身份证明来确认本人身份 

等级越高，身份确认越严格。



## Openssl 自签名证书以及颁发证书

如何使用openssl生成证书及签名

### 第一步，生成私钥

```csharp
$ openssl genrsa -out privatekey.pem 2048
```

查看生成的私钥内容

```php
$ file privatekey.pem 
privatekey.pem: PEM RSA private key
$ cat privatekey.pem
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA8AWq2V3g4B9fN7Tj37k0Wmut70ylRyziebyE3baA24pgixgu
8wpXztHdF5YixjbOdLvaqGQ3ck1CPRMD+cB3awgfw+/jPJqzdg2ACa9IFkIM5eaH
...
Zvib8+BsiAoiqXr4vAi8Lb64TJv3JDwOKEH/dnpXVmsDEt3wKRWX5A==
-----END RSA PRIVATE KEY-----
```

另外可以用openssl命令查看私钥的明细

```php
$ openssl rsa -in privatekey.pem -noout -text
Private-Key: (2048 bit)
modulus:
...
```



### 第二步，由私钥生产对应的公钥

```csharp
$ openssl rsa -in privatekey.pem -pubout -out publickey.pem
```

查看生成的公钥内容

```ruby
$ file publickey.pem 
publickey.pem: ASCII text
$ cat publickey.pem 
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8AWq2V3g4B9fN7Tj37k0
...
vQIDAQAB
-----END PUBLIC KEY-----
```



另外，也可以使用openssl命令查看公钥的明细

```php
$ openssl rsa -pubin -in publickey.pem -noout -text
Public-Key: (2048 bit)
Modulus:
...
```



### 第三步，根据私钥生成证书签名请求

```csharp
$ openssl req -new -key privatekey.pem -out csr.pem -subj "/C=CN/ST=BJ/L=BJ/O=HD/OU=dev/CN=hello/emailAddress=hello@world.com"
```



查看证书请求文件的内容

```ruby
$ file csr.pem 
csr.pem: PEM certificate request
$ cat csr.pem 
-----BEGIN CERTIFICATE REQUEST-----
MIICvjCCAaYCAQAweTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkJKMQswCQYDVQQH
...
c8L1GiAnIN8bXSWpZT2ZfHcnVbYvz4bgxFGTncA06JwDHw==
-----END CERTIFICATE REQUEST-----
```



也可以通过openssl命令查看证书请求文件的明细。

```php
$ openssl req -noout -text -in csr.pem
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=CN, ST=BJ, L=BJ, O=HD, OU=dev, CN=hello/emailAddress=hello@world.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                ...
```

结果还是看不懂哈(除了Modulus的内容就是publickey.pem的内容，就是说这里面包含了公钥的内容)



### 第四步，发送签发请求到CA进行签发，生成 x509证书

这里我们没有CA服务器，所以需要假装生成一个CA服务器

#### 4.1 生成CA私钥

```csharp
$ openssl genrsa -out ca.key 2048
```

#### 4.2 根据CA私钥生成CA的自签名证书

```csharp
$ openssl req -new -x509 -days 365 -key ca.key -out ca.crt -subj "/C=CN/ST=BJ/L=BJ/O=HD/OU=dev/CN=ca/emailAddress=ca@world.com"
```

注意这一步和前面第三步的区别，这一步直接生成自签名的证书，而在第三步生成的是证书签名请求，这个证书签名请求是要发给CA生成最终证书的。



查看自签名的CA证书

```ruby
$ file ca.crt 
ca.crt: PEM certificate
$ openssl x509 -in ca.crt -noout -text   
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            8a:6e:10:c5:f6:18:f7:67
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=BJ, L=BJ, O=HD, OU=dev, CN=ca/emailAddress=ca@world.com
        Validity
            Not Before: May 26 00:36:39 2018 GMT
            Not After : May 26 00:36:39 2019 GMT
        Subject: C=CN, ST=BJ, L=BJ, O=HD, OU=dev, CN=ca/emailAddress=ca@world.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:cf:0c:6b:ed:2a:d7:28:55:a2:54:5a:78:1c:6a:
                    ...
                    cb:c5
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                6E:00:06:26:92:A0:02:66:73:8C:A9:7E:47:DC:EB:A2:3F:91:F7:BC
            X509v3 Authority Key Identifier: 
                keyid:6E:00:06:26:92:A0:02:66:73:8C:A9:7E:47:DC:EB:A2:3F:91:F7:BC

            X509v3 Basic Constraints: 
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         bc:d7:92:12:56:30:10:a8:b3:cf:b0:0d:7c:52:79:7b:22:2a:
         ...
         e5:11:28:99
```



#### 4.3 使用CA的私钥和证书对用户证书签名

```objectivec
$ openssl x509 -req -days 3650 -in csr.pem -CA ca.crt -CAkey ca.key -CAcreateserial -out crt.pem
```



查看生成证书内容

```ruby
$ file crt.pem 
crt.pem: PEM certificate
$ cat crt.pem 
-----BEGIN CERTIFICATE-----
MIIDaTCCAlECCQDzYtuYa7OlUTANBgkqhkiG9w0BAQsFADB0MQswCQYDVQQGEwJD
...
Zo7/JmQs
tCqjMPMc1lPuS3zmHg==
-----END CERTIFICATE-----
$ openssl x509 -in crt.pem -noout -text
Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number:
            f3:62:db:98:6b:b3:a5:51
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=BJ, L=BJ, O=HD, OU=dev, CN=ca/emailAddress=ca@world.com
        Validity
            Not Before: May 26 00:40:35 2018 GMT
            Not After : May 23 00:40:35 2028 GMT
        Subject: C=CN, ST=BJ, L=BJ, O=HD, OU=dev, CN=hello/emailAddress=hello@world.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:b7:7b:c3:e4:12:65:b9:1d:04:8b:6d:b2:f4:ff:
                    ...
                    e3:bd
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
         8e:5f:5e:f3:fa:8a:bf:e4:7f:e1:84:99:24:3d:a6:86:ce:db:
         ...
         4b:7c:e6:1e
```



#### 4.4 什么是消息签名

对消息签名简单地说分为三部分：

1. 针对消息内容生成一个哈希值
2. 使用私钥对生成的哈希值进行加密
3. 然后把加密后的哈希值和你签名过的证书添加到消息块中