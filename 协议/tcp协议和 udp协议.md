##TCP协议（是全双工的，既双方都可以发送消息）

TCP中的 三次握手的基本原理和 SEQ 以及 ACK的序号

```
[SYN] SEQ=0，ACK=0 ###client-> server

[SYN,ACK] SEQ=0，ACK=1 ###server-> client

[ACK] SEQ=1，ACK =1 ###client-> server

----上面是 三次握手过程 下面是实际发送数据

[PSH,ACK] SEQ=1,ACK=1 lenth=12	###client-> server

[ACK] SEQ=1,ACK=13 lenth=0	###server-> client

[ACK] SEQ=1,ACK=13	lenth=50	###server-> client

[ACK] SEQ=13,ACK=51	lenth=0	###client-> server

	由于TCP是 全双工通道，所以 client 端维护的 SEQ 是 自己发送的数据的序列号，而 server端 维护的也是自己发送的序列号，（由于tcp是传输层协议，默认会将 数据分割成多个报文段进行发送，不同于 http请求，既请求->回应一说），所以各个端点所维护的SEQ 是不一样的，client 端 维护的SEQ表示client端 所发出去的数据，而 server端 则表示server端发出去的数据，因为 一个http请求会被分割成多个报文段进行传输，所以需要 seq 来进行维持，假如说用户请求一个网站，那么用户这边请求数据会被分割成多个报文段发送至服务器端（假如这里是顺序发送的），服务器端需要把接收到的数据 全部整合起来以后才知道用户到底是在请求哪个url，request body中又携带了什么数据。
	
	以第一个数据举例
	[PSH,ACK] SEQ=1,ACK=1 lenth=12	###client-> server
	这表示 当前 client 往server端 发送了长度为12的字节数据
	[ACK] SEQ=1,ACK=13 lenth=0	###server-> client
	当服务端接收到这个消息之后，会发送一个ack=13的消息给server端，ack=13 表示serever端已经接收到了这12字节的数据。
	[PSH,ACK] SEQ=1,ACK=13	lenth=50	###server-> client
	然后server端又向client端发送了 50字节的数据
	[ACK] SEQ=13,ACK=51	lenth=0	###client-> server
	client 接收到数据以后发送一个ack请求给client端，表示这50字节的数据已经接受，seq = 13 就是代表了这是 client端点发送数据包的累加长度，
	
	======================================================
	用户 --＞　服务器
	
	client--> server  
	
	用户的请求会被分割为多个数据包，假如为  client1,client2,client3 三个数据包，client1数据包有10字节，client2 也有10字节，client3 有5个字节
	
	那么 client的seq最终就是为 25 ，这表示client端所发送的数据包的大小（三次握手初始化的seq先不放进去），server端 也是如此
	
	client 每发一条数据，server端就需要回应一条 ack请求（len=0）表示client端发送的数据已经收到了，
ack就等于上次发送数据的seq的值加上给server端发送数据的lenth长度。（假如上次发送的seq值为20，又发了30字节数据，那么ack就等于50）


三次握手
[SYN] SEQ=0，ACK=0 len=1 		###client-> server

[SYN,ACK] SEQ=0，ACK=1 len=1 	###server-> client

[ACK] SEQ=1，ACK =1     	###client-> server

这三次握手就可以看成是每一次发送了1个字节的数据
client端先发送了一个消息并且len=1
server端收到这个消息之后给client端返回一个ack请求并且将ack置为1，表示 server端已经收到了这1个字节的数据，然后发送给client端一个字节数据
然后client端给server端发送一个ack请求，表示client端也收到了这一个字节的数据，将 ack表示为1

简要的说 就是 client端维护的ack 就等于 server端下一次发送的seq ，server端的ack就等于 client端下一次发送的seq.

######
三次握手并不是实际的要发送一个1字节长度的值，而是协议规定握手期间每一次请求都会消耗1个 seq 数值，所以三次握手下来 双方的seq 都被置为了1，三次握手就是为了初始化双方seq的值，将其全部置为1
```













###TCP的三次握手和四次挥手?

三次握手：

​	![1571955299541](assets\1571955299541.png)



![1571955661694](assets\1571955661694.png)









### TCP如果握手只有两次，会出现什么 ？以及 SYN Flood 攻击

三次握手是为了初始化双方seq的值，通知对方自己初始化的seq的值，以保证不会因为网络通信故障而导致包乱序。因为双方需要依赖于seq 的值 来传递数据，tcp最后会用这些序号来拼接数据



SYN Flood 攻击：

​	恶意程序会给服务器发送一个SYN的报文，发完以后就会下线了，服务器默认就会等63秒来断开这个链接，攻击者就会把服务器的syn队列耗尽了



首次握手隐患：

![1571963644366](assets\1571963644366.png)

​	![1571963747093](assets\1571963747093.png)



### TCP的四次挥手流程是什么，为什么需要四次挥手？

![1571963960556](assets\1571963960556.png)



注意:

​	服务器端发送的第一次挥手请求  seq = v 表示当前服务器端发送数据包的字节长度

​	服务器端发送的第二次挥手请求 seq = w, 可能是在CLOSE_WAITING状态时，又发送了一些数据给 客户端 所以 seq 可能变为 w 

![1571964736886](assets\1571964736886.png)

四次挥手的原因：

因为关闭连接需要双方都发送FIN包和 ACK包，所以就成了四次挥手，也就是

```
client -> server [FIN] 主动发送 关闭请求 

server -> client [ACK] 确认收到 client端发送的数据包，但是有些数据包可能还没有发送完成

server -> client [FIN,ACK] 全部发送完成之后才能发送关闭请求

clieng -> server [ACK] 表示client也收到了server端的关闭请求，来进行关闭
```





### TIME_WAIT和CLOSE_WAIT的区别 ？

CLOSE_WAIT 

表示服务器端接收到 客户端的第一次挥手请求，将状态更改为半关闭状态，这个时候服务器还是可以发送ack包给客户端的，等到服务器将数据全部发送完毕之后，将会发送第三次挥手的[FIN,ACK] 请求表示服务端的数据已经发送完成了。



TIME_WAIT

表示已经接收到服务器端发送的[FIN,ACK]请求，代表服务器端的数据已经全部发送完毕了，客户端需要返回一条 ack请求 给服务器端，来告知服务器端 可以完全关闭了。

TIME_WAIT状态表示 需要有足够的时间让 对方收到ack包，如过被动方没有收到ack包，就会重发FIN包，

避免新旧连接混淆











### TCP/IP如何保证可靠性，说说TCP头的结构 ？

![1571954406245](assets\1571954406245.png)



```
TCP的请求头包括，

src port，

dst port，

SEQ number（表示当前携带报文段的起始值+ 数据实际的大小），

ack number（期望收到对方下一个报文的第一个字节的序号，B收到A发送过来的报文，序号为301，字段值为200字节，就说明B收到了 301+200 到500的字节，那么B 期望收到A 下一个发送数据字节的序号为501）

Offset 

TCP Flags：

	URG:紧急指针标志

	ACK: 确认序号表示，为1 表示确认确认号有效，为0表示报文中不含确认信息

	PSH：提示接收端应用程序应该立即从tcp接受缓冲区中读走数据，为后续接收的数据让出空间 

	RST：表示要求对方重建连接。因为一些原因断开连接进行重新发送的数据 

	SYN：同步序号，表示建立一个连接

	FIN标志：表示告知对方本端要关闭连接了。 

WINDOW窗口：

表示 滑动窗口的大小，。               发送端和接收端的缓存大小，以此控制发送端发送数据的速率，达到流量控制



CheckSum：

 校验和

	由发送端填充，接收端对tcp报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意这个校验不仅包括tcp头部，也包括数据部分。这也是tcp可靠传输的一个重要保障



紧急指针：是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式  

```



TCP如何保证可靠性

1）应用数据被分割成TCP认为最合适发送的数据块。称为段（Segment）传递给IP层
2）当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。若没有及时收到确认，将重新发送这个报文段
3）当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送的，通常将推迟几分之一秒。
4）TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文也不进行确认（对方就会重复发送了）。
5）TCP承载与IP数据报来传输，而IP数据报可能会失序，所以TCP的报文段到达时也可能会失序。但是TCP收到数据后会重新排序到正确的顺序（通过序号）。
6）IP数据报会发生重复，TCP的接收端必须丢弃重复是数据
7）TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间







### Tcp的滑动窗口？

```
TCP的滑动窗口是结合于 TCP头部中的 window的大小

RTT 和 RTO
	RTT : 发送一个数据包到收到对应ACK，所花费的时间
	RTO：重传时间间隔（根据RTT来计算出来的）
	
TCP使用滑动窗口做流量控制和乱序重排
	保证TCP的可靠性
	保证TCP的流控特性

TCP的 计算属性表达式：
	
	发送端程序
	--------------------
	
```

![1571968989047](assets\1571968989047.png)



```
LastByteAcked 最后收到ack恢复的位置
LastByteWritten 已经发送但是还没收到ack恢复的
LastByteSent 发送还没收到ack恢复的位置

AdversitisedWindow：能够接受数据包的大小，接受方能够处理的数据量

EfferctiveWindow：能够发送的数据包的大小，发送方能够发送的数据量的大小

```

![1571969440060](assets\1571969440060.png)

滑动窗口滑动时，必须保证数据连续性被确认，就是32,33,34,35,都被确认以后才会滑动，如过只有34被确认是不会滑动的

![1571969559204](assets\1571969559204.png)



### TCP粘包和拆包产生的原因?



###TCP的四层模型是什么？

![1571954300564](assets\1571954300564.png)





###OSI的七层模型？

![1571954272617](assets\1571954272617.png)





## UDP协议

![1571965465220](assets\1571965465220.png)



![1571965517229](assets\1571965517229.png)