# 二叉堆

  二叉堆是一种特殊的堆，其实质是完全二叉树。二叉堆有两种：最大堆和最小堆。最大堆是指父节点键值总是大于或等于任何一个子节点的键值。而最小堆恰恰相反，指的是父节点键值总是小于任何一个子节点的键值。如“图1 最大堆”、“图2 最小堆”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-3b40974f3d0efd14.png?imageMogr2/auto-orient/strip|imageView2/2/w/669/format/webp)

图1 最大堆



![img](https:////upload-images.jianshu.io/upload_images/16446743-45b92635bbdbecd6.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp)

图2 最小堆



堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等。

# 数据存储

与二叉树不同的是二叉堆的数据是顺序存储，而不是链式存储。如“图3 二叉堆数据的存储方式”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-4920b060d099d63c.png?imageMogr2/auto-orient/strip|imageView2/2/w/652/format/webp)

图3 二叉堆数据的存储方式

# 操作

对于二叉堆，介绍以下几种操作：
 插入节点；
 上浮节点；
 删除节点；
 下沉节点；
 构建二叉堆；

**1.插入节点**
 在插入数据的时候，每插入的数据都是插入到二叉堆的最后一个位置，以最大堆为例，如“图4 插入数据”所示：
 

![img](https:////upload-images.jianshu.io/upload_images/16446743-33114f7467aa0460.png?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)

图4 插入数据



上图描述的是插入整数10，可以发现，在第二层的父节点5小于新插入的子节点10，这可怎么办？这不符合最大堆的性质呀！于是就有了上浮节点操作。

**2.上浮节点**
 插入新数据后（子节点10），我们让子节点10与其父节点5作比较，父节点小于子节点，于是将子节点上浮与父节点转换，如“图5 子节点上浮-01”所示：
 

![img](https:////upload-images.jianshu.io/upload_images/16446743-b60830ce0837c565.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)

图5 子节点上浮-01



接着再做同样的操作，子节点10与父节点8作比较，同样需要上浮，如“图6 子节点上浮-02”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-83e4ecbc7639547f.png?imageMogr2/auto-orient/strip|imageView2/2/w/636/format/webp)

图6 子节点上浮-02

再同样做同样操作，如“图7 子节点上浮-03”所示，直至父节点大于子节点或者子节点已经上浮到根节点即止。



![img](https:////upload-images.jianshu.io/upload_images/16446743-6c360de0bd15ee79.png?imageMogr2/auto-orient/strip|imageView2/2/w/654/format/webp)

图7 子节点上浮-03

**3.删除节点**
 在删除节点的时候，每次都是删除根节点，如“图8 删除节点”所示：
 

![img](https:////upload-images.jianshu.io/upload_images/16446743-0a147d03dbbdadb0.png?imageMogr2/auto-orient/strip|imageView2/2/w/694/format/webp)

图8 删除节点



在删除根节点之后，我们不可能让根节点位置无主吧？于是将二叉堆最后一个数据填充至根节点，如“图9 填充根节点”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-3611c319ebf50c5d.png?imageMogr2/auto-orient/strip|imageView2/2/w/653/format/webp)

图9 填充根节点

但是，我们又可以发现，填充上来的根节点比它的子节点小，这也不符合最大堆的性质呀！于是就有了下沉节点操作。

**4.下沉节点**
 填充数据（父节点5）之后，我们让父节点5与其两个子节点9、7作比较，看谁更大，父节点就往哪下沉，如“图10 下沉父节点-01”所示：
 

![img](https:////upload-images.jianshu.io/upload_images/16446743-db1c555a5e7bf487.png?imageMogr2/auto-orient/strip|imageView2/2/w/958/format/webp)

图10 下沉父节点-01


 接着再做同样的操作，父节点5与其两个子节点6、8作比较，再下沉。最终发现两个子节点都小于父节点，于是停止下沉（如果父节点下沉至叶节点位置时，也停止下沉）。如“图10 下沉父节点-02”所示：

![img](https:////upload-images.jianshu.io/upload_images/16446743-53a471f15a46a25d.png?imageMogr2/auto-orient/strip|imageView2/2/w/899/format/webp)

图10 下沉父节点-02



**5.构建 二叉堆**
 构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。
 比如此时有一个无序的二叉树，如“图11 无序二叉树”所示：
 

![img](https:////upload-images.jianshu.io/upload_images/16446743-2e5de9fb25675900.png?imageMogr2/auto-orient/strip|imageView2/2/w/710/format/webp)

图11 无序二叉树



首先从最后一个非叶子结点8开始，让其与两个子节点11、6作比较，然后做下沉节点操作，如“图12 节点下沉-01”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-4020f89b37b9de3e.png?imageMogr2/auto-orient/strip|imageView2/2/w/620/format/webp)

图12 节点下沉-01

接着是节点2，做同样的操作，如“图13 节点下沉-02”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-f47936477cef7431.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp)

图13 节点下沉-02

然后是节点5，如“图14 节点下沉-03”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-0a56c0a7dba015fb.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)

图14 节点下沉-03

最后是节点12，因为该节点都比其两个子节点大，所以无需下沉。
 最终，一颗无序的二叉树就构建成了一个最大堆了，如“图15 构建后的最大堆”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-b27b24b37af5f4cd.png?imageMogr2/auto-orient/strip|imageView2/2/w/686/format/webp)

图15 构建后的最大堆

# 时间复杂度

因为二叉堆是一棵完全二叉树，所以对于一个节点数为n的堆，它的高度不会超过log2n，因此二叉堆上浮和下沉的时间复杂度都为log2(n)。

# 代码实现

在代码实现之前，先说明一下二叉堆在处理的过程中是如何计算下标的，如“图16 下标获取”所示：



![img](https:////upload-images.jianshu.io/upload_images/16446743-d4cb1547d9c261f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/648/format/webp)

图16 下标获取



如上图所示，假设父节点的下标 parent=0，则其左子节点下标为Lchildren=2*parent+1，右子节点下标为Rchildren=2*parent+2，如上示为例：
 第 0 个数据的下标：parent = 0
 第 1 个数据的下标：Lchildren = 2*parent + 1 = 2*0+1 = 1
 第 2 个数据的下标：Rchildren = 2*parent + 2 = 2*0+2 = 2