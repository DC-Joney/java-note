#### 为什么使用索引？

为了避免全表扫描，能够快速查询数据



```
索引（存储引擎层实现）
	分类
		前缀索引
		聚簇索引、二级索引
			聚簇索引 只能为主键，他的叶子结点存放的是该行的数据
			二级索引：叶子节点存放的是主键
		覆盖索引
			查询中使用太多的列
			使用了双%号的like查询
		复合索引
		空间索引
	select count 查询
		默认会使用辅助索引 因为主键索引上的数据比较多会导致select(count)查询比较慢
	B-Tree索引
		索引匹配
			最左前缀
			匹配列前缀
			范围查询
			精确匹配左前列，并且范围匹配另外一列
			order by顺序必须一直
			索引列中所有列的方向(升序、降序)和order by字句完全一致
			order by只能给的字段全部在关联表中的第一张表中
		限制
			如果不是按照最左列开始查找，则无法使用索引
			使用索引时，不能跳过索引中的列
			not in 和<> 操作无法使用索引
			如果查询中有某个列的范围查询，则其右边的所有列则无法使用索引
			索引列上不能使用表达式或者函数
	hash索引
		先找到hash索引对应的行
		再根据行指针找到对应的记录
		hash无法用于排序
	innodb hash索引：根据innodb中的b-tree索引的使用情况自动建立的
	索引和锁
		使用索引来减少行锁
		如果索引扫描的行越少则行锁越少
	索引的维护和优化
		删除重复和冗余的索引
	索引限制：
		索引会增加写操作的成本（insert buffer）
```





#### 聚簇索引和 二级索引的区别？

![1572501049759](assets\1572501049759.png)

一级索引保存了当前行的一整行数据

二级索引是进行两次查找，二级索引保存的是 指向当前行主键的指针

```
根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+树；
如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
```



![1572967543563](assets\1572967543563.png)

![1572967755514](assets\1572967755514.png)





```
innodb的索引和数据文件是在一起的

如下图：
```



![1572501119089](C:/Users/Administrator/Desktop/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/assets/1572501119089.png)



####二级索引的检索过程

**select * from T where k between 3 and 5**

```
create table T (
    ID int primary key,
    k int NOT NULL DEFAULT 0,
    s varchar(16) NOT NULL DEFAULT '',
    index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg....);
```



![1572968689577](assets\1572968689577.png)

```
现在，我们一起来看看这条 SQL 查询语句的执行流程：

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；

2. 再到 ID 索引树查到 ID=300 对应的 R3；

3. 在 k 索引树取下一个值 k=5，取得 ID=500；

4. 再回到 ID 索引树查到 ID=500 对应的 R4；

5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束。

在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了 k索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。
```



#### 覆盖索引 

覆盖索引是为了减少数据回表查询的过程

```
  如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此MySQL 认为扫描行数是 2。
```



#### 联合索引

```
联合索引 在sql执行中默认是可以乱序的，mysql优化器会将sql优化成索引可以识别的形式进行执行

联合索引必须遵守最左匹配原则

限制：
	mysql会一直向右匹配直到遇到 > 、<、between、like 就会停止匹配（like为%%，单%是可以使用到索引的）
	索引列的顺序要和Order by语句的顺序完全一致
	索引中所有列的方法（升序，降序）和Order by字句完全一致
	Order by中的字段全部在关联表中的第一张表中
	
联合索引建议：
	
	最左匹配原则 

	经常会被使用的列优先

	选择性高的列优先

	宽度小的列优先

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名和年龄，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间
```

![1572501628426](assets\1572501628426.png)



联合索引的索引下推：

```
上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？

我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：

mysql> select * from tuser where name like '张 %' and age=10 and ismale=1

你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。

然后呢？
当然是判断其他条件是否满足。

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。
而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

图 3 和图 4，是这两个过程的执行流程图。

mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;
```



图 3 无索引下推执行流程

![1572969970703](assets\1572969970703.png)



图 4 索引下推执行流程

![1572969984071](assets\1572969984071.png)

在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。

图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4次。

图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次





####mysql数据文件收缩





#### 索引的重建







主键索引重建

```
alter table drop primary key

alter table add primary key

重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建
```



二级索引重建

alter table drop index

alter table add index 

```
重建索引 k 的做法是合理的，可以达到省空间的目的
```



索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

 alter table T engine=InnoDB





#### 普通索引和唯一索引

```
执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。

对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。

对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB
```



```
change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性

虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上

 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 purge。除了访问这个数据页会触发 purge 外，系统有后台线程会定期 purge。在数据库正常关闭（shutdown）的过程中，也会执行 purge 操作
 
 
 什么条件下可以使用 change buffer 呢?
 
 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer了。
 
因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示change buffer 的大小最多只能占用 buffer pool 的 50%
 
```

![1573007753369](assets\1573007753369.png)



```
change buffer 的使用场景
通过上面的分析，你已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？

因为 purge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 purge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 changebuffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。


反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 purge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。
```

执行 select * from t where k in (k1, k2)

![1573008264155](assets\1573008264155.png)

```
1. Page 1 在内存中，直接更新内存；
2. Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息
3. 将上述两个动作记入 redo log 中



```

![1573008352266](assets\1573008352266.png)

```
1. 读 Page 1 的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？

其实是不用的。你可以看一下图 3 的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。

2. 要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。

redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。
```



#### 字符串前缀索引

```
mysql> create table SUser(
ID bigint unsigned primary key,
email varchar(64),
...
)engine=innodb;


select f1, f2 from SUser where email='xxx';

mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

字符串前缀索引：
优点：
可以减少索引所占用的空间

缺点：

所以，如果使用 index1（即 email 整个字符串的索引结构）的话，可以利用覆盖索引，从index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。而如果使用 index2（即email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。

即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，因为系统并不确定前缀索引的定义是否截断了
完整信息。
```





####B+ 树 和 B树的区别是什么？



#### 联合索引最左匹配原则的原因？



联合索引是根据最左索引来依次对数据进行归档

![1572501716481](assets\1572501716481.png)





#### 自适应Hash索引？



####索引是建立越多越好吗？

```
数据量小的表不需要建立索引，建立会增加额外的索引开销

数据变更需要维护索引，更多的索引意味着更多的维护成本

更多的索引意味着更多的空间

```





#### 索引的DDL

```
创建索引
	create index index_name on table(col_name(n))
	n代表字符串的前几位
	
删除索引

修改索引
```



####索引的限制

```
索引上不允许使用函数或者表达式
不允许在索引上使用 %% 查询

联合索引：
```







#### 索引的优化

```
联合索引

	最左匹配原则 

	经常会被使用的列优先

	选择性高的列优先

	宽度小的列优先

尽量使用覆盖索引来进行查找
```

![1572445406719](assets\1572445406719.png)







![1572429369306](C:/Users/Administrator/Desktop/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/assets/1572429369306.png)



![1572429406610](C:/Users/Administrator/Desktop/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/assets/1572429406610.png)

![1572429682285](C:/Users/Administrator/Desktop/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/assets/1572429682285.png)

![1572429742216](C:/Users/Administrator/Desktop/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/assets/1572429742216.png)

![1572429789183](C:/Users/Administrator/Desktop/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/assets/1572429789183.png)

