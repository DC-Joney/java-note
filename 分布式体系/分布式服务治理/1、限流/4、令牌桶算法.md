## 令牌桶算法



### 特点

令牌桶算法是比较常见的限流算法之一，Google开源项目Guava中的RateLimiter使用的就是令牌桶算法。流程如下：

1. 所有的请求在处理之前都需要拿到一个可用的令牌才会被处理。
2. 根据限流大小，设置按照一定的速率往桶里添加令牌。
3. 桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝。
4. 请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除。

![525f132368ea4561710dcd3bc1a78516.png](assets/525f132368ea4561710dcd3bc1a78516.png)

令牌桶算法

单机伪代码如下，分布式环境可以使用Redisson。

```
class TokenBucketDemo { public long timeStamp = getNowTime(); public int capacity; // 桶的容量 public int rate; // 令牌放入速度 public int tokens; // 当前令牌数量 public boolean grant() { long now = getNowTime(); // 先添加令牌 tokens = min(capacity, tokens + (now - timeStamp) * rate); timeStamp = now; if (tokens < 1) { // 若桶中没有令牌,则拒绝 return false; } else { // 还有令牌，领取令牌 tokens -= 1; return true; } }}
```





### 实现

Guava 的 RateLimter 的实现

### 场景

1. 可以抵御突发流量，因为桶内的令牌数不会超过给定的最大值
2. 可以做到更加平滑的限流，因为令牌是匀速放入的。
3. 令牌桶算法允许流量一定程度的突发。(相比漏桶算法)

在时间点刷新的临界点上，只要剩余token足够，令牌桶算法会允许对应数量的请求通过，而后刷新时间因为token不足，流量也会被限制在外，这样就比较好的控制了瞬时流量。因此，令牌桶算法也被广泛使用。