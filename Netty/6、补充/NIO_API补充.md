# NIO API 补充

## FileChannel 

### FileChannel的force方法

FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。

force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。



## MappedByteBuffer



### MappedByteBuffer#isLoad

我们可以通过调用 isLoaded( )方法来判断一个被映射的文件是否完全加载内存了。
 如果该方法返回ture，意味着该缓冲区中的所有数据很可能完全加载到物理内存中了，因此可以在不产生任何虚拟内存页错误或I/O操作的情况下访问。
 不过，该方法返回false，并不一定意味着缓冲区的内容没有加载到物理内存中。

返回值是一个提示，而不是一个保证，因为底层操作系统在调用该方法返回的时候可能已经分出了一些缓冲区的数据





### MappedByteBuffer#load

**将此缓冲区内容加载到物理内存中。**

此方法尽最大努力确保当它返回时，该缓冲区的内容驻留在物理内存中。调用此方法可能会导致一些页面错误和I/O操作发生。

操作系统会采用虚拟内存映射，把缓冲区和文件建立虚拟内存映射。此映射使得操作系统的底层虚拟内存子系统可以根据需要将文件中相应区块的数据读进内存。已经在内存中或通过验证的页会占用实际内存空间，并且在它们被读进 RAM 时会挤出最近较少使用的其他内存页。（swap in，swap out）

在一个映射缓冲区上调用 load( )方法会是一个代价高的操作，因为它会导致大量的页调入（page-in），具体数量取决于文件中被映射区域的实际大小。然而，load( )方法返回并不能保证文件就会完全加载到内存，这是由于请求页面调入是动态的。具体结果会因某些因素而有所差异，这些因素包括：操作系统、文件系统，可用 Java 虚拟机内存，最大 Java 虚拟机内存，垃圾收集器实现过程等等。

请小心使用 load( )方法，它可能会导致您不希望出现的结果。该方法的主要作用是为提前加载文件埋单，以便后续的访问速度可以尽可能的快。
 对于那些要求近乎实时访问的程序，解决方案就是预加载。但是请记住，不能保证全部页都加载到内存，不管怎样，之后可能还会有页调入发生（操作系统自己维护，依赖操作系统的实现）。内存页什么时候swap in 和 swap out 受多个因素影响，这些因素中的许多都是不受 Java 虚拟机控制的。
 JDK 1.4 的 NIO 并没有提供一个可以把页面固定到物理内存上的API，尽管一些操作系统是支持这样做的。对于大多数程序，特别是交互性的或其他事件驱动（event-driven）的程序而言，为提前加载文件消耗资源是不划算的。在实际访问时分摊页调入开销才是更好的选择。让操作系统根据需要来调入页意味着不访问的页永远不需要被加载。同预加载整个被映射的文件相比，这很容易减少 I/O 活动总次数。操作系统已经有一个复杂的内存管理系统了，就让它来替您完成此工作吧！



### MappedByteBuffer#force

**将此缓冲区所做的内容更改强制写入包含映射文件的存储设备中。**

该方法会强制将此缓冲区上的任何更改写入映射到永久磁盘存储器上。

如果映射到该缓冲区的文件驻留在本地存储设备上，那么当该方法返回时，它保证对创建的缓冲区进行的所有更改，或者自上次调用该方法后，将被写入该设备。
 如果文件不驻留在本地设备上，则不提供这样的保证。

当用 MappedByteBuffer 对象来更新一个文件，您应该总是使用 MappedByteBuffer.force( )而非 FileChannel.force( )，因为通道对象可能
 不清楚通过映射缓冲区做出的文件的全部更改。MappedByteBuffer 没有不更新文件元数据的选项——元数据总是会同时被更新的。

如果映射是以 MapMode.READ_ONLY 或 MAP_MODE.PRIVATE 模式建立的，那么调用 force( )
 方法将不起任何作用，因为永远不会有更改需要应用到磁盘上（但是这样做也是没有害处的）。

